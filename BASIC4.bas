' PROGRAM DXF
DIM DXFINPUTRAW(6000) AS STRING
DIM X1(2000) AS DOUBLE
DIM Y1(2000) AS DOUBLE
DIM X1FINAL(2000, 50) AS DOUBLE
DIM Y1FINAL(2000, 50) AS DOUBLE
DIM exp1 AS LONG, num2 AS LONG
DIM X1G(400) AS DOUBLE
DIM Y1G(400) AS DOUBLE
DIM X2(2000) AS DOUBLE
DIM Y2(2000) AS DOUBLE
DIM X2E(2000) AS DOUBLE
DIM Y2E(2000) AS DOUBLE
DIM DIMXSORT(2000) AS DOUBLE
DIM DIMYSORT(2000) AS DOUBLE
DIM DIMX2SORT(2000) AS DOUBLE
DIM DIMY2SORT(2000) AS DOUBLE
DIM COUNTINGROUP(15) AS INTEGER
DIM TXTINPUTRAWADD1(4000) AS STRING
DIM TEXTTEMP AS STRING
C = 0
F = 0
A = 0
DIMSCT = 0
DIM YRANGEMAX AS DOUBLE
DIM YRANGEMIN AS DOUBLE
YRANGEMIN = 1000
GROUPSX = 0
DIM LINESZ AS SINGLE
LINESZ = 13.00
CHDIR "C:\Users\olang\Desktop\QB64\DXFDIVOTSORT\BASIC\" ''''''''''''''''''''''ONLY FOR TESTING
OPEN "2FE.DXF" FOR INPUT AS #1
OPEN "2FETEXTANDBORDER.txt" FOR INPUT AS #11
OPEN "OUTPUTSXY.TXT" FOR OUTPUT AS #2
OPEN "BORDERXY.TXT" FOR OUTPUT AS #5
OPEN "TESTOUTPUTGENERAL.TXT" FOR OUTPUT AS #3

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''READ DXFSAVE XY VALS INTO ARAY
DO UNTIL EOF(1)
    A = A + 1
    LINE INPUT #1, DXFINPUTRAW(A)

LOOP
DO UNTIL EOF(11)
    TEXTFILELINE = TEXTFILELINE + 1
    46
    LINE INPUT #11, TXTINPUTRAWADD1(TEXTFILELINE) ''''''''''''''''''''
    LOCOFNLINENUM1 = INSTR(1, TXTINPUTRAWADD1(TEXTFILELINE), "Q23")
    IF LOCOFNLINENUM1 > 0 THEN
        LOCOFNLINENUM1 = 0
        GOTO 46
    END IF
    IF TEXTFILELINE > 13 THEN
        LOCOFNLINENUM = INSTR(1, TXTINPUTRAWADD1(TEXTFILELINE), "N")
        IF LOCOFNLINENUM > 0 THEN
            TXTINPUTRAWADD1(TEXTFILELINE) = TXTINPUTRAWADD1(TEXTFILELINE) + "     " ''''''''' ADD 5 SPACE TO ACCEP ADD DIG
            TEXTTEMP = MID$(TXTINPUTRAWADD1(TEXTFILELINE), LOCOFNLINENUM + 1)
            MID$(TXTINPUTRAWADD1(TEXTFILELINE), (LOCOFNLINENUM + 1)) = "1" + TEXTTEMP

            PRINT TXTINPUTRAWADD1(TEXTFILELINE)
        END IF
    END IF
LOOP
CLOSE #11
_DELAY .02
OPEN "2FETEXTANDBORDER.txt" FOR OUTPUT AS #11


' SEARCH FOR SKIN_DIVOTS IN TEXT THEN SKIP A LINE GRAB THE VAL SKIP A LINE GRAB THE VAL
'THAT GIVES X AND Y CORDS


FOR E = 1 TO A
    STARTPOS = INSTR(1, DXFINPUTRAW(E), "SKIN_DIVOTS")
    IF E >= 4 THEN STARTPOSA = INSTR(1, DXFINPUTRAW(E - 4), "POINT")

    IF STARTPOS > 0 AND STARTPOSA > 0 THEN



        PRINT #2, DXFINPUTRAW(E + 2) + ","; ''''''''''' GET THE INFO FOR THE XY VALS  AND  WRITE TO FILE AS DATA    '''' THE FIRST SKIN_DIVOTS MAY NEED TO BE EXCLUDED FROM THE CALCULATIONS AS IT SEEMS IT IS A SETUP PHASE
        PRINT #2, DXFINPUTRAW(E + 4) + ",";


    END IF
NEXT E


CLOSE #2 '''''''''''''''''''''''CLOSE  THE FILE WE WROTE TO AS XY COMMA DATA, READ IT
_DELAY .02

OPEN "OUTPUTSXY.TXT" FOR INPUT AS #4

DO UNTIL EOF(4) ''''''''''''''''' READ DATA AS NUMERICAL VALUES  DIVOTS
    F = F + 1
    INPUT #4, X1(F), Y1(F) ''''''''''''''''''''''''''''''''''''''''''''''''' POINTS
    IF X1(F) < 0.0000005 THEN

        X1(F) = 0
    END IF
    IF Y1(F) < 0.0000005 THEN
        Y1(F) = 0
    END IF

LOOP

'''''''''''''''''''''''''''''''''''''''' NEED TO GET THE BORDER INFO TO DEFINE THE SORT ORDER FOR THE SORTING ALGORITHM   '''''''''''''''''






FOR E = 1 TO A

    STARTPOS2 = INSTR(1, DXFINPUTRAW(E), "SKIN_BORDER")
    IF E >= 4 THEN STARTPOSB = INSTR(1, DXFINPUTRAW(E - 4), "LINE")
    IF STARTPOS2 > 0 AND STARTPOSB > 0 THEN




        PRINT #5, DXFINPUTRAW(E + 2) + ","; ''''''''''''''''''''''''''''''''''''''''''''''' EACH LINE HAS A START AND STOP VALUE IN FOLLOWING FORM LINE SKIP SKIN BORDER SKIP X SKIP Y SKIP  XEND SKIP YEND
        PRINT #5, DXFINPUTRAW(E + 4) + ",";
        PRINT #5, DXFINPUTRAW(E + 8) + ",";
        PRINT #5, DXFINPUTRAW(E + 10) + ",";
    END IF
NEXT E


CLOSE #5 '''''''''''''''''''''''CLOSE  THE FILE WE WROTE TO AS XY COMMA DATA, READ IT
_DELAY .02

OPEN "BORDERXY.TXT" FOR INPUT AS #5

DO UNTIL EOF(5) ''''''''''''''''' READ DATA AS NUMERICAL VALUES
    G = G + 1
    INPUT #5, X2(G), Y2(G), X2E(G), Y2E(G)
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''NEED LOGIC TO FIGURE OUT IF THE VALS ARE BEING CORRECTLY ASSIGNED AS IF THERE ARE MORE
    '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''LINES IN ONE DIRECTION IT WILL PICK THEM UP AS THE WRONG TYPE
    ' BAD CODE

    '''''''''''''''''''''''''''''''''''''''''''''''''''FIX FOR ROUNDIN TO EXPONENTIAL VAL
    IF X2(G) < 0.0000005 THEN
        X2(G) = 0
    END IF
    IF Y2(G) < 0.0000005 THEN
        Y2(G) = 0
    END IF '''''''''''FIX FOR ROUNDIN TO EXPONENTIAL VAL


    IF X2E(F) < 0.0000005 THEN

        X2E(F) = 0
    END IF
    IF Y2E(F) < 0.0000005 THEN
        Y2E(F) = 0
    END IF


    DIMXSORT(G) = X2(G)
    DIMYSORT(G) = Y2(G)
    DIMX2SORT(G) = X2E(G)
    DIMY2SORT(G) = Y2E(G)


    IF Y2(G) > YRANGEMAX THEN YRANGEMAX = Y2(G)
    IF Y2(G) < YRANGEMIN THEN YRANGEMIN = Y2(G)



LOOP
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

FOR L = G TO 1 STEP -1


    FOR Z = 1 TO L



        IF DIMXSORT(Z) > DIMXSORT(L) THEN ''''''''''''''''''''''''''''''''''''''''''''   THIS IS THE SORT IT WILL ARR THE BORDERS ACC TO X VAL LEAS TO GREATES NOW HAVE TO PUT IT TO USE AND HOW TO KEEP LINES TOGETHER  T
            SWAP DIMXSORT(Z), DIMXSORT(L) ''''' COULD JIST USE THIS AS THE OUTLINES AND FIGURE CUTS OUT LATER ... <<<< GOOD IDEA
            SWAP DIMYSORT(Z), DIMYSORT(L)


        END IF
        IF DIMXSORT(Z) = DIMXSORT(L) AND DIMYSORT(Z) > DIMYSORT(L) THEN
            SWAP DIMXSORT(Z), DIMXSORT(L)
            SWAP DIMYSORT(Z), DIMYSORT(L)
        END IF
    NEXT Z


NEXT L

'FOR TEST = 1 TO G
'PRINT "DIM  SORT "; DIMXSORT(TEST),
'PRINT DIMYSORT(TEST)
'NEXT TEST
'SLEEP

'''''''''''''''''''
'''''''''''''''''''''''NOW I HAVE TEH BORDER  X  VALUES SORTED BY  LEAST TO GREATEST  Y VALS FOLLOW THE X VALUES

'FOR L = 1 TO (G - 2) STEP 2 ''''''''''''''''''''''CONTROLLS THE X BOUNDRIEXS EACH STEP GOES TO THE NEXT X MIN MAX
'GROUPSX = GROUPSX + 1
FOR DIVOTCNT = 1 TO F ''''''''''''''''''''''''''' RUNS THROUGH EVERY DIVOT
    IF X1(DIVOTCNT) > DIMXSORT(1) AND X1(DIVOTCNT) < DIMXSORT(3) AND Y1(DIVOTCNT) > DIMYSORT(1) AND Y1(DIVOTCNT) < DIMYSORT(2) THEN ''''''''''''''''''''''''''''''''THIS PUTS THE BOUNDRIES ON THE DIVOTS
        FINAL = FINAL + 1
        GROUPSX = 1
        COUNTINGROUP(1) = COUNTINGROUP(1) + 1
        X1FINAL(FINAL, GROUPSX) = X1(DIVOTCNT) '''''''''''''''''''''''''''' PUTS THE XY VALS INTO A 2 D ARRAY FINAL IS THE INDEX OF DIVOTS GROUPSX IS THE GROUP THE DIVOTST FALL INTO
        Y1FINAL(FINAL, GROUPSX) = Y1(DIVOTCNT)
    END IF
NEXT DIVOTCNT
FINAL = 0
FOR DIVOTCNT = 1 TO F
    IF X1(DIVOTCNT) > DIMXSORT(4) AND X1(DIVOTCNT) < DIMXSORT(6) AND Y1(DIVOTCNT) > DIMYSORT(4) AND Y1(DIVOTCNT) < DIMYSORT(8) THEN ''''''''''''''''''''''''''''''''THIS PUTS THE BOUNDRIES ON THE DIVOTS
        FINAL = FINAL + 1
        GROUPSX = 2
        COUNTINGROUP(2) = COUNTINGROUP(2) + 1
        X1FINAL(FINAL, GROUPSX) = X1(DIVOTCNT) '''''''''''''''''''''''''''' PUTS THE XY VALS INTO A 2 D ARRAY FINAL IS THE INDEX OF DIVOTS GROUPSX IS THE GROUP THE DIVOTST FALL INTO
        Y1FINAL(FINAL, GROUPSX) = Y1(DIVOTCNT)
    END IF
NEXT DIVOTCNT
FINAL = 0
FOR DIVOTCNT = 1 TO F
    IF X1(DIVOTCNT) > DIMXSORT(6) AND X1(DIVOTCNT) < DIMXSORT(8) AND Y1(DIVOTCNT) > DIMYSORT(7) AND Y1(DIVOTCNT) < DIMYSORT(8) THEN ''''''''''''''''''''''''''''''''THIS PUTS THE BOUNDRIES ON THE DIVOTS
        FINAL = FINAL + 1
        GROUPSX = 3
        COUNTINGROUP(3) = COUNTINGROUP(3) + 1
        X1FINAL(FINAL, GROUPSX) = X1(DIVOTCNT) '''''''''''''''''''''''''''' PUTS THE XY VALS INTO A 2 D ARRAY FINAL IS THE INDEX OF DIVOTS GROUPSX IS THE GROUP THE DIVOTST FALL INTO
        Y1FINAL(FINAL, GROUPSX) = Y1(DIVOTCNT)
    END IF

NEXT DIVOTCNT
FINAL = 0
FOR DIVOTCNT = 1 TO F

    IF X1(DIVOTCNT) > DIMXSORT(3) AND X1(DIVOTCNT) < DIMXSORT(5) AND Y1(DIVOTCNT) > DIMYSORT(7) AND Y1(DIVOTCNT) < DIMYSORT(3) THEN ''''''''''''''''''''''''''''''''THIS PUTS THE BOUNDRIES ON THE DIVOTS
        FINAL = FINAL + 1
        GROUPSX = 4
        COUNTINGROUP(4) = COUNTINGROUP(4) + 1
        X1FINAL(FINAL, GROUPSX) = X1(DIVOTCNT) '''''''''''''''''''''''''''' PUTS THE XY VALS INTO A 2 D ARRAY FINAL IS THE INDEX OF DIVOTS GROUPSX IS THE GROUP THE DIVOTST FALL INTO
        Y1FINAL(FINAL, GROUPSX) = Y1(DIVOTCNT)
    END IF



NEXT DIVOTCNT
'NEXT L

'  TRYING TO FIGURE OUT HOW TO SORT TEH VALUES BASED OFF OF COUNTER CLOCKWISE MOTION
GROUPSX = 1
IF GROUPSX = 1 THEN
    FOR L = COUNTINGROUP(GROUPSX) TO 1 STEP -1
        FOR Z = 1 TO L
            IF Y1FINAL(Z, GROUPSX) > Y1FINAL(L, GROUPSX) THEN '''''''''''''''''''''''''''''''''''''''SORT THE DIVOTS COUNTERCLOCK WISE
                SWAP X1FINAL(Z, GROUPSX), X1FINAL(L, GROUPSX) ''''' SORTS THEM
                SWAP Y1FINAL(Z, GROUPSX), Y1FINAL(L, GROUPSX)
            END IF
        NEXT Z
    NEXT L
END IF
GROUPSX = 2
IF GROUPSX = 2 THEN
    FOR L = COUNTINGROUP(GROUPSX) TO 1 STEP -1
        FOR Z = 1 TO L
            IF X1FINAL(Z, GROUPSX) > X1FINAL(L, GROUPSX) THEN
                SWAP X1FINAL(Z, GROUPSX), X1FINAL(L, GROUPSX) '
                SWAP Y1FINAL(Z, GROUPSX), Y1FINAL(L, GROUPSX)
            END IF
        NEXT Z
    NEXT L
END IF
GROUPSX = 3
IF GROUPSX = 3 THEN
    FOR L = COUNTINGROUP(GROUPSX) TO 1 STEP -1
        FOR Z = 1 TO L
            IF Y1FINAL(Z, GROUPSX) < Y1FINAL(L, GROUPSX) THEN
                SWAP X1FINAL(Z, GROUPSX), X1FINAL(L, GROUPSX)
                SWAP Y1FINAL(Z, GROUPSX), Y1FINAL(L, GROUPSX)
            END IF
        NEXT Z
    NEXT L
    GROUPSX = 4
    IF GROUPSX = 4 THEN
        FOR L = COUNTINGROUP(GROUPSX) TO 1 STEP -1
            FOR Z = 1 TO L
                IF X1FINAL(Z, GROUPSX) < X1FINAL(L, GROUPSX) THEN
                    SWAP X1FINAL(Z, GROUPSX), X1FINAL(L, GROUPSX)
                    SWAP Y1FINAL(Z, GROUPSX), Y1FINAL(L, GROUPSX)
                END IF
            NEXT Z
        NEXT L
    END IF
END IF
TEMPL1$ = "X&Y&"
TEMPL2$ = "Y&"
TEMPL3$ = "X&"
'FOR L = 1 TO F
'LINECT = LINECT + 1
'PRINT #3, USING TEMPL1$; LINECT; X1FINAL()
'LINECT = LINECT + 1
'PRINT #3, "N"                        SDC
'NEXT L

'  -*******************************************
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''output divots to POST FILE LST/////////////////////////////// START OUTPUT TO POST FILE FOR BIG LASER

FOR POTT = 1 TO 4
    FOR POT = 1 TO COUNTINGROUP(POTT)
        exp1 = 10 ^ 3: num2 = X1FINAL(POT, POTT) * exp1: X1FINAL(POT, POTT) = num2 / exp1
        exp1 = 10 ^ 3: num2 = Y1FINAL(POT, POTT) * exp1: Y1FINAL(POT, POTT) = num2 / exp1
    NEXT POT
NEXT POTT
''''''''''''''''''''''''''''''''''''''FOR 11 FINAL OUTPUT

FOR FOUT = 1 TO 12
    PRINT #11, TXTINPUTRAWADD1(FOUT)
NEXT FOUT


PRINT #11, "N12G00X" + LTRIM$(STR$(CSNG(X1FINAL(1, 1)))) + "Y" + LTRIM$(STR$(CSNG(Y1FINAL(1, 1))))

FOR POTT = 1 TO 4
    FOR POT = 1 TO COUNTINGROUP(POTT)


        LINESZ = LINESZ + 0.01
        exp1 = 10 ^ 2: num2 = LINESZ * exp1: LINESZ = num2 / exp1
        IF POT = 1 AND POTT = 1 THEN
            PRINT #11, "N" + LTRIM$(STR$(LINESZ)) + "Q23"
            GOTO 347
        END IF

        PRINT DIMXSORT(POTT), DIMYSORT(POTT); "DIMS"
        PRINT POT, POTT
        PRINT X1FINAL(POT, POTT); "XF"
        PRINT Y1FINAL(POT, POTT); "YF"

        PRINT #11, "N"; LTRIM$(STR$(LINESZ));
        IF X1FINAL(POT, POTT) <> X1FINAL(POT - 1, POTT) AND Y1FINAL(POT, POTT) <> Y1FINAL(POT - 1, POTT) THEN
            PRINT #11, USING TEMPL1$; LTRIM$(STR$(CSNG(X1FINAL(POT, POTT)))); LTRIM$(STR$(CSNG(Y1FINAL(POT, POTT))))
        END IF
        IF X1FINAL(POT, POTT) = X1FINAL(POT - 1, POTT) AND Y1FINAL(POT, POTT) <> Y1FINAL(POT - 1, POTT) THEN
            PRINT #11, USING TEMPL2$; LTRIM$(STR$(CSNG(Y1FINAL(POT, POTT))))
        END IF
        IF X1FINAL(POT, POTT) <> X1FINAL(POT - 1, POTT) AND Y1FINAL(POT, POTT) = Y1FINAL(POT - 1, POTT) THEN
            PRINT #11, USING TEMPL3$; LTRIM$(STR$(CSNG(X1FINAL(POT, POTT))))
        END IF

        LINESZ = LINESZ + 0.01

        exp1 = 10 ^ 2: num2 = LINESZ * exp1: LINESZ = num2 / exp1


        PRINT #11, "N" + LTRIM$(STR$(LINESZ)) + "Q23"
        '  SLEEP
        347
    NEXT POT
NEXT POTT
LINESZ = LINESZ + 0.01

exp1 = 10 ^ 2: num2 = LINESZ * exp1: LINESZ = num2 / exp1

PRINT #11, "N"; LTRIM$(STR$(LINESZ)); MID$(TXTINPUTRAWADD1(13), 7)
FOR FOUT = 14 TO TEXTFILELINE
    PRINT #11, TXTINPUTRAWADD1(FOUT)
NEXT FOUT



